\section{Using the memuse Package}


\subsection{Constructing memuse Objects}




\subsection{Default Parameters}

The \code{.UNIT} object defaults to \code{best} and like the weird guy at work, should probably just be left alone.  Functions that need to know an input unit, such as the constructor \code{mu()}, have default argument \code{unit=.UNIT}.  Realistically, you are probably better off modifying that argument as necessary than changing \code{.UNIT}.  For example, you want to construct a 100 KiB \code{memuse} object, you probably just want to call
\begin{lstlisting}[language=rr]
mu(100, "KiB")
\end{lstlisting}
This is equivalent to calling
\begin{lstlisting}[language=rr]
mu(102400)
\end{lstlisting}
since the default \code{.UNIT=best} will make the choice to switch the units from b to KiB once you breach 1024 bytes.  This sounds a lot more confusing than it really is.

More useful is the \code{.PREFIX} parameter.  This must either be \code{SI} or \code{IEC}, with the latter being the package default.  
\begin{lstlisting}[language=rr]
> .PREFIX <- "SI"
> x <- mu(10, "kb")
> x
10.000 KB
> swap.prefix(x)
9.766 KiB
\end{lstlisting}



\subsection{Methods}
Aside from the constructor, you have already seen one very useful method:  \code{swap.prefix()}.  In addition to these, we have several other obvious methods, such as \code{swap.unit()}, \code{swap.names()}, \code{print()}, \code{show()}, etc.  But we also have some simple arithmetic, namely \code{`+`} (addition), \code{`*`} (multiplication), and \code{`\^{}`} (exponentiation).  So for example:
\begin{lstlisting}[language=rr]
> mu(100) + mu(200)
300.000 B
> mu(100) * mu(200) # 100*200/1024
19.531 KiB
\end{lstlisting}
Other arithmetic of memuse objects is available, including division, as well as 

Finally, we have the methods that inspired the creation of this entire dumb thing in the first place:  \code{howbig()} and \code{howmany()}.  The former takes in the dimensions of a matrix (\code{nrow} rows and \code{ncol} columns) and returns the memory usage (as the package namesake would imply) of the object.  So for example, if you wanted to perform a principal components decomposition on a 100,000 by 100,000 matrix via SVD (as we have), then you would need:
\begin{lstlisting}
> howbig(100000, 100000)
74.506 GiB
\end{lstlisting}
Of ram just to store the data.  Another interesting anecdote about this sized matrix is that we were able to generate it in just over a tenth of a second.  Pretty cool, eh?

As mentioned before, there is also the \code{howmany()} method which does somewhat the reverse of \code{howbig()}.  Here you pass a \code{memuse} object and get a matrix size out.  You can pass (exactly) one argument \code{nrow} or \code{ncol} in addition to the \code{memuse} object; the method will determine the maximum possible size of the outlying dimension in the obvious way.  If no additional argument is passed, then the largest square matrix dimensions will be returned.



\subsection{Package Demos}

In addition to all of the above, the \pkg{memuse} package includes several demos.  You can execute them via the command:
\begin{lstlisting}[title=List of Demos]
### (Use Rscript.exe for windows systems)

# Basic construction/use of memuse objects
Rscript -e "demo(demo, package='memuse', ask=F, echo=F)"
# Arithmetic
Rscript -e "demo(demo2, package='memuse', ask=F, echo=F)"
# howbig/howmany examples
Rscript -e "demo(demo3, package='memuse', ask=F, echo=F)"
\end{lstlisting}
